```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Enhanced Tank Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    canvas { display: block; background: #333; margin: 0 auto; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1800" height="1000"></canvas>
  <script>
    (function() {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let lastTime = performance.now();
      let deltaTime = 0;
      let gameTime = 0;
      const keys = {};
      let mouseX = canvas.width / 2, mouseY = canvas.height / 2;
      let score = 0;
      let nextBossSpawnTime = 30;

      const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        vx: 0,
        vy: 0,
        turretAngle: 0,
        bodyAngle: 0,
        reloadTime: 0,
        health: 100,
        radius: 15,
        trackTimer: 0,
        dead: false
      };

      const bullets = [];
      const enemies = [];
      const explosions = [];
      const tracks = [];
      let enemySpawnCooldown = 4.0;
      const MAX_ENEMIES = 10;

      window.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; });
      window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });
      canvas.addEventListener("mousemove", e => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
      });
      canvas.addEventListener("mousedown", e => { if (e.button === 0) shoot(); });

      function shoot() {
        if (player.reloadTime <= 0) {
          bullets.push({
            x: player.x,
            y: player.y,
            angle: player.turretAngle,
            speed: 950,
            owner: 'player',
            radius: 6
          });
          player.reloadTime = 0.8;
        }
      }

      function createExplosion(x, y, count = 15, speedMultiplier = 1, lifeMultiplier = 1, 
                              colors = ['#FF6600', '#FF9900', '#FF3300'], 
                              baseRadius = 3, radiusVariation = 5) {
        for(let i = 0; i < count; i++) {
          const life = (0.5 + Math.random() * 0.3) * lifeMultiplier;
          explosions.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 400 * speedMultiplier,
            vy: (Math.random() - 0.5) * 400 * speedMultiplier,
            life: life,
            initialLife: life,
            radius: baseRadius + Math.random() * radiusVariation,
            color: colors[Math.floor(Math.random() * colors.length)]
          });
        }
      }

      function spawnEnemy() {
        let pos = { x: 0, y: 0 };
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { pos.x = Math.random() * canvas.width; pos.y = -20; }
        else if (edge === 1) { pos.x = Math.random() * canvas.width; pos.y = canvas.height + 20; }
        else if (edge === 2) { pos.x = -20; pos.y = Math.random() * canvas.height; }
        else { pos.x = canvas.width + 20; pos.y = Math.random() * canvas.height; }

        const targetSide = Math.random() < 0.5 ? 'left' : 'right';
        const targetX = targetSide === 'left' ? canvas.width * 0.25 : canvas.width * 0.75;
        const targetY = Math.random() * canvas.height;

        enemies.push({
          x: pos.x,
          y: pos.y,
          shootTimer: 2.5 + Math.random() * 2,
          radius: 15,
          entryTime: undefined,
          orbitDir: Math.random() < 0.5 ? 1 : -1,
          desiredOrbitDist: 200 + Math.random() * 300,
          orbitSpeed: 0.6 + Math.random() * 0.8,
          vx: 0,
          vy: 0,
          orbitVariation: Math.random() * Math.PI * 2,
          orbitPhase: Math.random() * Math.PI * 2,
          acceleration: 120 + Math.random() * 30,
          maxSpeed: 100 + Math.random() * 30,
          lastDistance: 0,
          bodyAngle: 0,
          health: 2,
          hitFlashTimer: 0,
          dead: false,
          trackTimer: 0,
          targetX: targetX,
          targetY: targetY
        });
      }

      function spawnBoss() {
        let pos = { x: 0, y: 0 };
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { pos.x = Math.random() * canvas.width; pos.y = -20; }
        else if (edge === 1) { pos.x = Math.random() * canvas.width; pos.y = canvas.height + 20; }
        else if (edge === 2) { pos.x = -20; pos.y = Math.random() * canvas.height; }
        else { pos.x = canvas.width + 20; pos.y = Math.random() * canvas.height; }

        enemies.push({
          x: pos.x,
          y: pos.y,
          shootTimer: 3.0,
          radius: 40,
          entryTime: undefined,
          orbitDir: Math.random() < 0.5 ? 1 : -1,
          desiredOrbitDist: 400,
          orbitSpeed: 0.3,
          vx: 0,
          vy: 0,
          orbitVariation: Math.random() * Math.PI * 2,
          orbitPhase: Math.random() * Math.PI * 2,
          acceleration: 60,
          maxSpeed: 50,
          lastDistance: 0,
          bodyAngle: 0,
          turretAngle: 0,
          health: 11,
          hitFlashTimer: 0,
          dead: false,
          trackTimer: 0,
          targetX: canvas.width / 2,
          targetY: canvas.height / 2,
          isBoss: true,
          burstCount: 0,
          burstCooldown: 0
        });
      }

      function enemyShoot(enemy) {
        let dx = player.x - enemy.x;
        let dy = player.y - enemy.y;
        let dist = Math.hypot(dx, dy);
        const bulletSpeed = 450;
        let timeToHit = (dist * 1.3) / bulletSpeed;
        let targetX = player.x + player.vx * timeToHit;
        let targetY = player.y + player.vy * timeToHit;
        let angle = Math.atan2(targetY - enemy.y, targetX - enemy.x);
        angle += (Math.random() - 0.5) * 0.15;
        bullets.push({
          x: enemy.x,
          y: enemy.y,
          angle: angle,
          speed: bulletSpeed,
          owner: 'enemy',
          radius: 5,
          color: '#FF4444'
        });
      }

      function update(dt) {
        gameTime += dt;

        // Spawn boss every 30 seconds
        if (gameTime >= nextBossSpawnTime) {
          spawnBoss();
          nextBossSpawnTime += 30;
        }

        // Update track lifetimes
        for (let i = tracks.length - 1; i >= 0; i--) {
          tracks[i].lifetime -= dt;
          if (tracks[i].lifetime <= 0) {
            tracks.splice(i, 1);
          }
        }

        // Player movement
        const ACCEL = 250;
        const FRICTION = 700;
        const MAX_SPEED = 160;
        const BASE_TURN_SPEED = 3.2;
        const MIN_TURN_SPEED = 1.2;

        let acceleration = 0;
        if (keys['w']) acceleration = ACCEL;
        if (keys['s']) acceleration = -ACCEL * 0.5;

        player.vx += Math.cos(player.bodyAngle) * acceleration * dt;
        player.vy += Math.sin(player.bodyAngle) * acceleration * dt;

        if (!keys['w'] && !keys['s']) {
          let speed = Math.hypot(player.vx, player.vy);
          if (speed > 0) {
            let deceleration = FRICTION * dt;
            if (speed > deceleration) {
              let factor = (speed - deceleration) / speed;
              player.vx *= factor;
              player.vy *= factor;
            } else {
              player.vx = 0;
              player.vy = 0;
            }
          }
        }

        let speed = Math.hypot(player.vx, player.vy);
        if (speed > MAX_SPEED) {
          player.vx = (player.vx / speed) * MAX_SPEED;
          player.vy = (player.vy / speed) * MAX_SPEED;
        }

        player.x += player.vx * dt;
        player.y += player.vy * dt;
        player.x = Math.max(player.radius, Math.min(player.x, canvas.width - player.radius));
        player.y = Math.max(player.radius, Math.min(player.y, canvas.height - player.radius));

        // Add player tracks
        const currentSpeed = Math.hypot(player.vx, player.vy);
        if (currentSpeed > 0) {
          player.trackTimer += dt;
          if (player.trackTimer >= 0.1) {
            tracks.push({
              x: player.x,
              y: player.y,
              angle: player.bodyAngle,
              lifetime: 2.0
            });
            player.trackTimer = 0;
          }
        } else {
          player.trackTimer = 0;
        }

        let currentTurnSpeed = MIN_TURN_SPEED + (1 - (currentSpeed / MAX_SPEED)) * (BASE_TURN_SPEED - MIN_TURN_SPEED);
        if (keys['a']) player.bodyAngle -= currentTurnSpeed * dt;
        if (keys['d']) player.bodyAngle += currentTurnSpeed * dt;

        player.turretAngle = Math.atan2(mouseY - player.y, mouseX - player.x);

        if (player.reloadTime > 0) {
          player.reloadTime -= dt;
          if (player.reloadTime < 0) player.reloadTime = 0;
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          b.x += Math.cos(b.angle) * b.speed * dt;
          b.y += Math.sin(b.angle) * b.speed * dt;
          if (b.x < -10 || b.x > canvas.width + 10 ||
              b.y < -10 || b.y > canvas.height + 10) {
            bullets.splice(i, 1);
          }
        }

        enemies.forEach(enemy => {
          if (enemy.dead) {
            if (Math.random() < 0.3) {
              createExplosion(
                enemy.x, enemy.y,
                3, 0.1, 1.0,
                ['#FFFF00', '#FFA500'],
                10, 0
              );
            }

            const FRICTION = 500;
            let speed = Math.hypot(enemy.vx, enemy.vy);
            if (speed > 0) {
              let deceleration = FRICTION * dt;
              if (speed > deceleration) {
                let factor = (speed - deceleration) / speed;
                enemy.vx *= factor;
                enemy.vy *= factor;
              } else {
                enemy.vx = 0;
                enemy.vy = 0;
              }
            }
            enemy.x += enemy.vx * dt;
            enemy.y += enemy.vy * dt;
            enemy.x = Math.max(enemy.radius, Math.min(enemy.x, canvas.width - enemy.radius));
            enemy.y = Math.max(enemy.radius, Math.min(enemy.y, canvas.height - enemy.radius));
            return;
          }

          // Add enemy tracks
          const enemySpeed = Math.hypot(enemy.vx, enemy.vy);
          if (enemySpeed > 0) {
            enemy.trackTimer += dt;
            if (enemy.trackTimer >= 0.1) {
              tracks.push({
                x: enemy.x,
                y: enemy.y,
                angle: enemy.bodyAngle,
                lifetime: 2.0
              });
              enemy.trackTimer = 0;
            }
          } else {
            enemy.trackTimer = 0;
          }

          if (enemy.entryTime === undefined) {
            let dx = enemy.targetX - enemy.x;
            let dy = enemy.targetY - enemy.y;
            let dist = Math.hypot(dx, dy);

            if (dist > 0) {
              let dirX = dx / dist;
              let dirY = dy / dist;

              let desiredVx = dirX * enemy.maxSpeed;
              let desiredVy = dirY * enemy.maxSpeed;

              let dvx = desiredVx - enemy.vx;
              let dvy = desiredVy - enemy.vy;
              let dvMag = Math.hypot(dvx, dvy);

              if (dvMag > 0) {
                let accelStep = enemy.acceleration * dt;
                if (dvMag > accelStep) {
                  dvx = (dvx / dvMag) * accelStep;
                  dvy = (dvy / dvMag) * accelStep;
                }
                enemy.vx += dvx;
                enemy.vy += dvy;
              }
            }

            enemy.x += enemy.vx * dt;
            enemy.y += enemy.vy * dt;

            if (dist < 50 || (enemy.x >= enemy.radius && enemy.x <= canvas.width - enemy.radius &&
                enemy.y >= enemy.radius && enemy.y <= canvas.height - enemy.radius)) {
              enemy.entryTime = gameTime;
            }

            const currentSpeed = Math.hypot(enemy.vx, enemy.vy);
            if (currentSpeed > 0) {
              enemy.bodyAngle = Math.atan2(enemy.vy, enemy.vx);
            }
          } else {
            // Boss-specific behavior
            if (enemy.isBoss) {
              // Update turret angle
              let dx = player.x - enemy.x;
              let dy = player.y - enemy.y;
              let desiredAngle = Math.atan2(dy, dx);
              let angleDiff = desiredAngle - enemy.turretAngle;
              angleDiff = ((angleDiff + Math.PI) % (Math.PI * 2)) - Math.PI;
              enemy.turretAngle += angleDiff * 2.0 * dt;

              // Shooting logic
              enemy.shootTimer -= dt;
              if (enemy.shootTimer <= 0 && enemy.burstCount === 0) {
                enemy.burstCount = 10;
                enemy.burstCooldown = 0;
                enemy.shootTimer = 0;
              }

              // Handle burst firing
              if (enemy.burstCount > 0) {
                enemy.burstCooldown -= dt;
                while (enemy.burstCooldown <= 0 && enemy.burstCount > 0) {
                  const totalSpread = 3 * Math.PI / 180;
                  const startAngle = enemy.turretAngle - totalSpread / 2;
                  const stepAngle = totalSpread / 9;
                  const currentIndex = 10 - enemy.burstCount;
                  const angle = startAngle + stepAngle * currentIndex;

                  bullets.push({
                    x: enemy.x,
                    y: enemy.y,
                    angle: angle,
                    speed: 1700,
                    owner: 'enemy',
                    radius: 5,
                    color: '#FF4444'
                  });

                  enemy.burstCount--;
                  enemy.burstCooldown += 0.2;
                }

                if (enemy.burstCount === 0) {
                  enemy.shootTimer = 3.0;
                }
              }
            } else {
              let dx = player.x - enemy.x;
              let dy = player.y - enemy.y;
              let dist = Math.hypot(dx, dy);
              enemy.lastDistance = dist;

              if (dist > 0) {
                const dynamicOrbitDist = enemy.desiredOrbitDist + 50 * Math.sin(enemy.orbitPhase + gameTime * 0.8);
                const dynamicOrbitSpeed = enemy.orbitSpeed * (1 + 0.2 * Math.sin(enemy.orbitPhase + gameTime * 1.2));

                let directX = dx / dist;
                let directY = dy / dist;
                let tangentX = -directY;
                let tangentY = directX;

                let distToDesired = dist - dynamicOrbitDist;
                let directWeight = distToDesired * 0.5;

                enemy.orbitVariation += dt * 0.6;
                let currentOrbitSpeed = dynamicOrbitSpeed * 
                    (0.9 + 0.2 * Math.sin(enemy.orbitVariation));

                let moveX = (directX * directWeight) + 
                            (tangentX * enemy.orbitDir * currentOrbitSpeed);
                let moveY = (directY * directWeight) + 
                            (tangentY * enemy.orbitDir * currentOrbitSpeed);

                let moveMag = Math.hypot(moveX, moveY);
                if (moveMag > 0) {
                  moveX /= moveMag;
                  moveY /= moveMag;
                }

                let desiredVx = moveX * enemy.maxSpeed;
                let desiredVy = moveY * enemy.maxSpeed;

                let dvx = desiredVx - enemy.vx;
                let dvy = desiredVy - enemy.vy;
                let dvMag = Math.hypot(dvx, dvy);
                if (dvMag > 0) {
                  let accelStep = enemy.acceleration * dt;
                  if (dvMag > accelStep) {
                    dvx = (dvx / dvMag) * accelStep;
                    dvy = (dvy / dvMag) * accelStep;
                  }
                  enemy.vx += dvx;
                  enemy.vy += dvy;
                }

                enemy.x += enemy.vx * dt;
                enemy.y += enemy.vy * dt;

                const currentSpeed = Math.hypot(enemy.vx, enemy.vy);
                if (currentSpeed > 0) {
                  enemy.bodyAngle = Math.atan2(enemy.vy, enemy.vx);
                }
              }

              if (enemy.entryTime !== undefined && gameTime - enemy.entryTime >= 1) {
                enemy.x = Math.max(enemy.radius, Math.min(enemy.x, canvas.width - enemy.radius));
                enemy.y = Math.max(enemy.radius, Math.min(enemy.y, canvas.height - enemy.radius));
              }

              enemy.shootTimer -= dt;
              if (enemy.shootTimer <= 0) {
                if (dist > 100 && dist < 800) {
                  enemyShoot(enemy);
                  enemy.shootTimer = 3.0 + Math.random() * 2.0;
                } else {
                  enemy.shootTimer = 0.5;
                }
              }

              if (enemy.hitFlashTimer > 0) {
                enemy.hitFlashTimer -= dt;
              }
            }
          }
        });

        // Enemy-enemy collisions
        for (let i = 0; i < enemies.length; i++) {
          for (let j = i + 1; j < enemies.length; j++) {
            const e1 = enemies[i];
            const e2 = enemies[j];
            const dx = e1.x - e2.x;
            const dy = e1.y - e2.y;
            const distance = Math.hypot(dx, dy);
            const minDistance = e1.radius + e2.radius;
            if (distance < minDistance) {
              const overlap = (minDistance - distance) / 2;
              e1.x += (dx / distance) * overlap;
              e1.y += (dy / distance) * overlap;
              e2.x -= (dx / distance) * overlap;
              e2.y -= (dy / distance) * overlap;

              e1.x = Math.max(e1.radius, Math.min(e1.x, canvas.width - e1.radius));
              e1.y = Math.max(e1.radius, Math.min(e1.y, canvas.height - e1.radius));
              e2.x = Math.max(e2.radius, Math.min(e2.x, canvas.width - e2.radius));
              e2.y = Math.max(e2.radius, Math.min(e2.y, canvas.height - e2.radius));
            }
          }
        }

        // Player-enemy collisions
        enemies.forEach(enemy => {
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const distance = Math.hypot(dx, dy);
          const minDistance = player.radius + enemy.radius;
          if (distance < minDistance) {
            const overlap = (minDistance - distance) / 2;
            player.x += (dx / distance) * overlap;
            player.y += (dy / distance) * overlap;
            enemy.x -= (dx / distance) * overlap;
            enemy.y -= (dy / distance) * overlap;

            player.x = Math.max(player.radius, Math.min(player.x, canvas.width - player.radius));
            player.y = Math.max(player.radius, Math.min(player.y, canvas.height - player.radius));
            enemy.x = Math.max(enemy.radius, Math.min(enemy.x, canvas.width - enemy.radius));
            enemy.y = Math.max(enemy.radius, Math.min(enemy.y, canvas.height - enemy.radius));
          }
        });

        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          if (b.owner === 'player') {
            for (let j = enemies.length - 1; j >= 0; j--) {
              let enemy = enemies[j];
              let dx = b.x - enemy.x;
              let dy = b.y - enemy.y;
              if (Math.hypot(dx, dy) < enemy.radius + b.radius) {
                if (!enemy.dead) {
                  enemy.health--;
                  enemy.hitFlashTimer = 0.1;
                  if (!enemy.isBoss) {
                    const pushForce = 6000;
                    enemy.vx += Math.cos(b.angle) * pushForce * dt;
                    enemy.vy += Math.sin(b.angle) * pushForce * dt;
                  }
                  if (enemy.health <= 0) {
                    enemy.dead = true;
                    if (enemy.isBoss) {
                      score += 1000;
                      createExplosion(
                        enemy.x, enemy.y,
                        100, 2.0, 1.5,
                        ['#FFFF00', '#FFA500'],
                        10, 15
                      );
                    } else {
                      score += 100;
                      createExplosion(
                        enemy.x, enemy.y,
                        20, 1.5, 1.2,
                        ['#FF0000', '#FFA500', '#FFFF00', '#FFFFFF'],
                        3, 5
                      );
                    }
                  } else {
                    createExplosion(enemy.x, enemy.y, 5, 0.8, 0.5);
                  }
                } else {
                  createExplosion(enemy.x, enemy.y, 5, 0.8, 0.5);
                  const pushForce = 6000;
                  enemy.vx += Math.cos(b.angle) * pushForce * dt;
                  enemy.vy += Math.sin(b.angle) * pushForce * dt;
                }
                bullets.splice(i, 1);
                break;
              }
            }
          } else if (b.owner === 'enemy') {
            let dx = b.x - player.x;
            let dy = b.y - player.y;
            if (Math.hypot(dx, dy) < player.radius + b.radius) {
              player.health -= 10 + Math.random() * 7;
              createExplosion(player.x, player.y, 10, 1.2, 0.8);
              bullets.splice(i, 1);
              if (player.health <= 0) {
                player.dead = true;
                createExplosion(
                  player.x, player.y,
                  50, 2.0, 1.5,
                  ['#FFA500', '#FF0000', '#FFFF00'],
                  10, 5
                );
                setTimeout(() => {
                  alert("Game Over!");
                  resetGame();
                }, 2000);
              }
            }

            // Enemy bullets vs dead enemies
            for (let j = enemies.length - 1; j >= 0; j--) {
              const enemy = enemies[j];
              if (enemy.dead) {
                const edx = b.x - enemy.x;
                const edy = b.y - enemy.y;
                if (Math.hypot(edx, edy) < enemy.radius + b.radius) {
                  createExplosion(enemy.x, enemy.y, 5, 0.8, 0.5);
                  const pushForce = 6000;
                  enemy.vx += Math.cos(b.angle) * pushForce * dt;
                  enemy.vy += Math.sin(b.angle) * pushForce * dt;
                  bullets.splice(i, 1);
                  break;
                }
              }
            }
          }
        }

        // Update explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
          const e = explosions[i];
          e.x += e.vx * dt;
          e.y += e.vy * dt;
          e.life -= dt;
          e.radius *= 0.95;
          if (e.life <= 0) explosions.splice(i, 1);
        }

        enemySpawnCooldown -= dt;
        if (enemySpawnCooldown <= 0 && enemies.filter(e => !e.dead).length < MAX_ENEMIES) {
          spawnEnemy();
          enemySpawnCooldown = 4.0;
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw tracks
        tracks.forEach(track => {
          ctx.save();
          ctx.translate(track.x, track.y);
          ctx.rotate(track.angle);
          ctx.globalAlpha = track.lifetime * 0.25;
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(-8, -5);
          ctx.lineTo(8, -5);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(-8, 5);
          ctx.lineTo(8, 5);
          ctx.stroke();
          ctx.restore();
        });

        explosions.forEach(e => {
          ctx.fillStyle = e.color;
          ctx.globalAlpha = e.life / e.initialLife;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        });

        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.bodyAngle);
        ctx.fillStyle = player.dead ? "black" : "green";
        ctx.fillRect(-15, -10, 30, 20);
        ctx.restore();

        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.turretAngle);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(20, 0);
        ctx.stroke();
        ctx.restore();

        enemies.forEach(enemy => {
          ctx.save();
          ctx.translate(enemy.x, enemy.y);
          ctx.rotate(enemy.bodyAngle);
          ctx.fillStyle = enemy.dead ? "#111111" : 
                         (enemy.isBoss ? "#3366FF" : (enemy.hitFlashTimer > 0 ? "white" : "red"));
          if (enemy.isBoss) {
            ctx.fillRect(-40, -30, 80, 60);
          } else {
            ctx.fillRect(-15, -10, 30, 20);
          }
          ctx.restore();

          if (!enemy.dead) {
            let turretAngle, turretLength, lineWidth, strokeStyle;
            if (enemy.isBoss) {
              turretAngle = enemy.turretAngle;
              turretLength = 60;
              lineWidth = 12;
              strokeStyle = "#4B0082";
            } else {
              turretAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
              turretLength = 20;
              lineWidth = 4;
              strokeStyle = "darkred";
            }
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(turretAngle);
            ctx.strokeStyle = strokeStyle;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(turretLength, 0);
            ctx.stroke();
            ctx.restore();
          }
        });

        bullets.forEach(b => {
          ctx.fillStyle = b.color ? b.color : (b.owner === 'player') ? "#FFFF00" : "#FF4444";
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(mouseX - 10, mouseY);
        ctx.lineTo(mouseX + 10, mouseY);
        ctx.moveTo(mouseX, mouseY - 10);
        ctx.lineTo(mouseX, mouseY + 10);
        ctx.stroke();

        if (player.reloadTime > 0) {
          let reloadFraction = 1 - player.reloadTime / 0.8;
          ctx.strokeStyle = "cyan";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(mouseX, mouseY, 15, -Math.PI / 2, -Math.PI / 2 + reloadFraction * Math.PI * 2);
          ctx.stroke();
        }

        // Health bar
        ctx.fillStyle = "#444";
        ctx.fillRect(10, 10, 200, 25);
        ctx.fillStyle = "#4CAF50";
        ctx.fillRect(10, 10, 200 * (player.health / 100), 25);
        
        ctx.fillStyle = "white";
        ctx.font = "20px sans-serif";
        ctx.fillText("Score: " + score, 10, 60);
      }

      function resetGame() {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.vx = 0;
        player.vy = 0;
        player.health = 100;
        player.dead = false;
        bullets.length = 0;
        enemies.length = 0;
        explosions.length = 0;
        tracks.length = 0;
        enemySpawnCooldown = 4.0;
        score = 0;
        nextBossSpawnTime = 30;
      }

      function gameLoop(time) {
        deltaTime = (time - lastTime) / 1000;
        lastTime = time;
        update(deltaTime);
        draw();
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
```
